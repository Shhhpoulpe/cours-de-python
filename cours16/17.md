# Semaine de Formation du 16 au 17 novembre 2020 - M1-IOT  

_______________

# Au programme ü§ñ

* Lundi 16 novembre :
	* Machine Learning : la classification avec les CART  
	* Mini projet  
  
* Mardi 17 novembre :   
	* Le framework [Streamlit](https://www.streamlit.io)
	* TP : r√©alisation d'une data app 



_______________



## Suivi üìà

Cr√©er un repo github et faire a minima deux pushs par jour (matin : 11h30 & aprem : 16h30) afin que je vois ou vous en √™tes üëå


## Machine Learning : la classification avec les CART üë®‚Äçüéì

Ce cours va √™tre tr√®s orient√© pratique, le but est de vous faire comprendre les principes th√©oriques des arbres de d√©cision, qui permettent d‚Äô√©tablir des r√®gles successives permettant de classer des observations ou de faire des r√©gressions. Et vous allez pour la premi√®re fois dans ce cours apprendre √† coder un algorithme de machine learning du d√©but √† la fin afin que vous puissiez voir et comprendre se qui se cache derri√®re les fonctions bien pratiques de python.


On parle de classification lorsque la variable cible est qualitative (cat√©gorielle), cas que nous traiterons dans un second temps. Ici nous nous int√©ressons au Regression Trees qui interviennent dans le cas d‚Äôune variable cible quantitative (cf sch√©ma ci-dessous). Leur avantage r√©side dans leur repr√©sentation graphique ais√©ment lisible. L‚Äôarbre est compos√© de trois types d‚Äô√©l√©ments :

*   La racine, o√π r√©side l‚Äôensemble des donn√©es d‚Äôapprentissage.
*   Les noeuds/branches, qui repr√©sente les points √† partir de la racine o√π les donn√©es sont s√©par√©es en deux groupes selon un crit√®re li√© aux variables explicatives.
*   Les feuilles, qui sont les noeuds terminaux de l‚Äôarbre et auxquels sont associ√©s un valeur dans le cas o√π ***Y*** est quantitative et une classe lorsque ***Y*** est qualitative.

Ainsi √† partir de la racine on d√©fini un noeud qui divise l‚Äôensemble des donn√©es selon un crit√®re li√© √† une variable explicative, pour chacune des deux branches ainsi cr√©√©es on r√©p√®te le m√™me proc√©d√©, et ainsi de suite jusqu‚Äô√† ce qu‚Äôaucune division ne satisfasse le crit√®re de construction d‚Äôun noeud et on d√©finit alors un noeud terminal ou feuille.

![decision_tree](https://lh4.googleusercontent.com/v9UQUwaQTAXVH90b-Ugyw2_61_uErfYvTBtG-RNRNB_eHUFq9AmAN_2IOdfOETnbXImnQVN-wPC7_YzDgf7urCeyhyx5UZmuSwV8BVsV8VnHxl1KtgpuxDifJ4pLE23ooYXLlnc)

### Construction d‚Äôun arbre al√©atoire
#### Principe g√©n√©ral

L‚Äôalgorithme de construction de l‚Äôarbre al√©atoire se structure de la fa√ßon suivante :



*   Initialisation : On consid√®re la racine comme l‚Äôensemble des donn√©es de la base d‚Äôapprentissage.
*   Pour chaque ensemble/sous-ensemble, on d√©finit un noeud :
    *   On s√©lectionne une variable explicative ***X*** et on d√©finit un crit√®re de coupure, un seuil si ***X*** est quantitative, ou un partage en groupes de modalit√©s si ***X*** est qualitative.
    *   On marque le noeud comme terminal si aucun crit√®re de division n‚Äôest satisfaisant, et on lui associe une valeur ou une classe selon la nature de ***Y***.
*   On interrompt la construction de l‚Äôarbre lorsque tous les noeuds sont terminaux.

Afin de mener √† son terme cet algorithme, nous avons besoin de plusieurs choses :



1. Un crit√®re de s√©lection de la meilleure division
2. Une r√®gle pour d√©finir si un noeud est terminal
3. Une m√©thode pour assigner √† chaque feuille une valeur ou une classe

On ne s'attardera pas dans ce cours sur les crit√®res de divisions, la construction des noeuds et crit√®re d‚Äôarr√™t. 

### Type de classification 

Il existe deux types de classification: 

* Classification binaire 
* Classification multiple 


### Interpr√©tation 

Les arbres de decisions que nous venons de voir sont un mod√®le d'apprentissage supervis√©. Ils sont particulierement appreci√© pour leur lisibilit√© et leur interpr√©tation directe. 


#### Indice de Gini

Cette m√©thode permet d‚Äô√©valuer l‚Äôimportance d‚Äôune variable au niveau d‚Äôun noeud, elle mesure la d√©croissance de la fonction d‚Äôh√©t√©rog√©n√©it√© si on utilise la variables explicative utilis√©e pour le noeud par celle que l‚Äôon souhaite √©valuer. L‚Äôimportance g√©n√©rale de la variable est alors une sommes des d√©croissance d‚Äôh√©t√©rog√©n√©it√© mesur√©es, pond√©r√©e par le nombres d‚Äôobservation √† chaque noeud.

### Feature importance 

Avoir un modele avec une certaine mesure de pr√©cision c'est bien, mais savoir les crit√®res sur lesquelles il se base pour produire sa d√©cision c'est mieux. 

Chaque mod√®le d'arbre dispose de sa m√©thode de feature importance afin d‚Äô√©valuer l‚Äôimportance de chacune des variables pour la pr√©diction.

Ci-dessous un exemple graphique de feature importance pour un algorithme de classification dans le domaine m√©dicale. 

![feature_importance_example](https://christophm.github.io/interpretable-ml-book/images/importance-cervical-1.png)

## Un exemple de code avec sklearn 
Vous trouverez un exemple de CART de la librairie scikit-learn ainsi qu'une rapide pr√©sentation de `graphviz` la librairie qui permet d'afficher les arbre [ici](https://gist.github.com/bdallard/9d33771e77ba11d848c60f366dcc0271)



## Mini projet 

Le livrable : Jupyter notebook avec les datas (ou liens raw git  pour acc√©der aux datas si > 5Mo)
le travail devra √™tre d√©pos√© sur un gist et l‚Äô√©tudiant devra envoyer le lien par mail ou messagerie

Contraintes : 

* Data avec minimum 15 colonnes avec au moins une colonne repr√©sentant une date
	* Vous pouvez  
* Un maximum de commentaires dans le code texte type Markdown apr√®s chaque graphique/tableau (ex: description textuelle des features apr√®s chargement)
* Tous les graphiques doivent √™tre lisible (taille du graphique, infos repr√©sent√©), si diagramme pas lisible, en faire une version filtr√©e dessous
* Exposer concr√®tement votre probl√©matique / question √† d√©finir : quel est le but de votre mod√®le et √† quelle situation m√©tier peut il correspondre ?

**Partie 1 : Analyse graphique des donn√©es (Dataviz)** 

* Diagrammes de r√©partition des donn√©es (type gaussienne sur les donn√©es)
* V√©rification du nombre de donn√©es, si plusieurs donn√©es sont peu repr√©sent√©s (<3%) alors regrouper dans une seule et m√™me cat√©gorie, 1 pie chart avant/apres
* Nettoyage des donn√©es manquantes, encodage (OneHot, dictionnaire ou Sklearn Encoder)
* Boites √† moustache avec donn√©es extr√™mes
* Heatmap + observations sur les corr√©lations

**Partie 2: Model Building**

* 2 algorithmes avec 2 param√®tres diff√©rents (ex: max_depth, n_estimators,‚Ä¶.) que vous expliquerez en commentaire
* Affichage des coefficients/ accuracy

**Partie 3: Features Importance** 

* Affichage sous forme de barplot
* Autre forme d‚Äôaffichage si vous avez le temps 

**Partie 4: Model R√©ex√©cution avec les features s√©lectionn√©s** 

* Affichage des metrics standard et commentaire sur la pertinence
* Un rapport PDF en plus du repo git (4pages max) sous forme de rapport projet/note de synthese 


## Le framework [Streamlit](https://www.streamlit.io) üë®‚Äçüéì

Vous trouverez ici le cours sur [gist](https://gist.github.com/bdallard/3a7cad831e041950a7703cebe498af55)

## TP : r√©alisation d'une data app 

votre mission est de construire une petite application de visualisation interactive de donn√©es avec l‚Äôoutil Streamlit vu au chapitre pr√©c√©dent, qui contiendra les fonctionnalit√©s suivantes :   

* Charger des jeux de donn√©es (au moins 2) pr√©sents dans votre r√©pertoire local
	* il faudra donc que votre application pointe un chemin et sorte les fichier (dataset) du repertoire point√©
* Afficher le dataset charg√© suivant un nombre de ligne entr√©es par l‚Äôutilisateur
* Afficher le nom des colonnes du dataset 
* Afficher le type des colonnes du dataset ainsi que les colonnes s√©lectionn√©es 
* La shape du dataset, par lignes et par colonnes
* Afficher les statistiques descriptives du dataset
* Afficher plusieurs type de graphique dans une partie visualisation avec notamment : 
	* Une heatmap des corr√©lations avec Matplotlib et Seaborn (avec les valeurs annot√©s)
	* Un graphique en barres afin de visualiser la taille du dataset par caract√©ristiques (on pourra notamment grouper les donn√©es afin d‚Äôavoir des graphiques plus pr√©cis)

Et enfin une derni√®re partie dite ¬´ visualisation personnalisable ¬ª qui permettra de : 

* S√©lectionner le type de graphique √† tracer
S√©lectionner des colonnes dans le jeux de donn√©es afin de g√©n√©rer le graphique
* **(bonus)**√Ä noter que suivant certain jeux de donn√©es il y aura des graphiques qui n‚Äôauront pas de sens capturez les dans des exceptions üßê
